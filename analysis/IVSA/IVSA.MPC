\*****************************\
\IVSA.MPC
\does fixed ratio, progressive ratio, or extinction with/without drug paired stims based on values of setting variables
\Written by Price E. Dickson
\2015-08-04
\*****************************\



\************************************************************
\--NOTES--\
\   1.  set session parameters in S1 OF S.S.1 and using the constants
\   2.  S32 is the null state in all state sets. Point to it if you
\       want to dead-end your code.
\   3.  S.S.32 starts z pulses. Work backwards.
\   4.  z pulses are never called by name in main code, but
\       rather using code macros to make reading the code easier
\************************************************************



\************************************************************
\--INPUTS AND OUTPUTS--\

\Inputs should not be in level mode. Change this using dip switches on the control
\unit hardware.

\--INPUTS--\
^LeftLeverIR        = 1
^RightLeverIR       = 2
^PelletReceptacleIR = 3
^FloorIR = 4

\--OUTPUTS--\
^LeftLever       = 1
^RightLever      = 2
^PelletDispenser = 3
^LeftStim        = 4
^RightStim       = 5
^HouseLight      = 7
^SyringePump     = 8
\************************************************************


\************************************************************
\--THESE ARE CONSTANTS FOR IF STATEMENTS AND LEVER ASSIGNMENT - DO NOT CHANGE--\
^True = 1
^False = 0
^Left = 1
^Right = 2
\************************************************************


\************************************************************
\--CONSTANTS--\
\a bunch of other vars that would be constants are in the settings file
^MaxInfusionDuration = 800                         \max centiseconds of infusion duration - to protect from overdose from incorrect infusion duration in Setting_InfusionDuration
^FillCatheterDurationCentiseconds = 100            \pump on duration required to fill the dead space in the cath on the first infusion of the session
^HouseLightBackOnTimerDuration = 4320000        \Centiseconds from start of the session until we turn the house light back on. This should be equivalent to 12 hours if the lights are off for 12 hours every night.
^VarsPerBlock = 100                                \this is the number of variables that can be used per block.
                                                \This will be multiplied by the current block number (1-12)
                                                \and added to the index of vars A(200) - ? to get to
                                                \the var of the current block. Current block is held by A(40).
                                                \For example, Total_ActiveLeverPresses is hold by A(160). Var that holds
                                                \ActiveLeverPresses for whatever block were in
                                                \is  A(160 + ^VarsPerBlock * A(40))). Then just increment A(40) by 1
                                                \each time we move to the next block.
\************************************************************



\************************************************************
\--DISCRETE VARIABLES--\
\   all variables below are part of the A array declared directly below.

\****
DIM A = 20000
\****

\--timers [0-39]--\
\   A(0) = session timer - keeps track of session time to the centisecond (i.e., 10 ms)
\   A(1) = block timer - keeps track of block time to the centisecond (i.e., 10 ms)
\   A(2) = infusion timer - keeps track infusion duration in centisecond (i.e., 10 ms)
\   A(3) = stim light timer - duration of stim lights after infusion
\   A(4) = timeout timer - duration of timeout after infusion
\    A(5) = NOT USED
\   A(6) = keeps track of program time - this is just used for updating the program time on the display, not for internal timing
\   A(7) = keeps track of program time - this is just used for updating the program time on the display, not for internal timing
\   A(8) = keeps track of program time - this is just used for updating the program time on the display, not for internal timing
\    no longer used   A(9) = program timer - keeps track time to the centisecond (i.e., 10 ms) from when you start the program, not when session starts; this is used for turning on/off house lights to maintain light cycle and delaying the start of the session

\   A(10) = keeps track of session time - this is just used for updating the session time on the display, not for internal timing
\   A(11) = keeps track of session time - this is just used for updating the session time on the display, not for internal timing
\   A(12) = keeps track of session time - this is just used for updating the session time on the display, not for internal timing

\    A(13) = house light on timer - This is started with the session timer but will keep running after the session is over. It is for turning the house light back on 12 hours after the session starts to keep the light dark cycle consistent
\   A(14) = Session time at which the next floor IR infusion is allowed

\--internal variables [40-59]--\
\   A(40) = CurrentBlock - the block that we're currently in [1-12]
\   A(41) = active presses since last infusion on an FR schedule
\   A(42) = NOT USED
\    A(43) = temp variable holding active presses in current block - for calculating percentage active presses in current block
\    A(44) = temp variable holding right presses in current block - for calculating percentage active presses in current block

\--session parameters [60-79]--\
\Time values should be declared as integers in centiseconds.
\They are internally converted to seconds.
\   A(60) = Setting_ActiveLever_1_Left_2_Right
\    A(61) = Setting_ExtinctionSession_1_True_0_False
\   A(62) = Setting_InfusionDuration [centiseconds]
\    A(63) = Setting_AcquisitionSession_1_True_0_False - first block timer won't start until after "Setting_InfusionsBeforeBlock1DuringAcquisition" infusions during an acquisition session
\    A(64) = Setting_DelayUntilStart [centiseconds] - this is used if you want to, for example, start the program at 4 pm but have the session start several hours later
\    NO LONGER USED A(65) = Setting_HouseLightOffDelay [centiseconds] - set to zero if not using; if > 0 house light will be turned on at beginning of program and then turn off after indicated duration, presumably when overhead lights go off at night
\    NO LONGER USED A(66) = Setting_HouseLightOnDelay [centiseconds] - set to zero if not using; if > 0 house light will turn on after indicated delay, presumably when overhead lights turn on in the morning - if program is still running it will override this
\    A(67) = Setting_FR_Or_PR_Schedule_1_FR_2_PR
\    A(68) = Setting_FRResponseRequirement [only used if FR schedule is selected]
\    A(69) = Setting_TestingDuringDarkPeriod_1_True_0_False - if true house light will be off except during timeout; it false house light will be on except during timeout
\    A(70) = Setting_BlockDuration [centiseconds] - block length in centiseconds
\    A(71) = Setting_NumberOfBlocksInSession [max 195]- session will end as soon as this number is exceded
\    A(72) = Setting_MaxSessionDuration - session will end when this time is reached, regardless of anything else
\    A(73) = Setting_StimLightDuration [centiseconds] - length of stim lights on after a lever press; must be shorter than timeout
\    A(74) = Setting_TimeOutDuration [centiseconds] - length of timeout after an infusion
\    A(75) = Setting_InfusionsBeforeBlock1DuringAcquisition
\    A(76) = Setting_DrugPairedStimuliDuringExtinction_1_True_0_False - only checked if we are using an extinction schedule as indicated by A(61)
\    A(77) = Setting_DebuggingMode_1_True_0_False  - verbose output on the screen if True if false or any number other than "1" output will be non-verbose

\--flags [80-119]--\
\   A(80) = Flag_TimeOutInProgress - description [1 = True 0 = False]
\    A(81) = NOT USED
\    A(82) = Flag_SessionInProgress - [1 = True 0 = False]
\    A(83) = Flag_FloorIRInfusionInProgress

\--indexes [120-159]--\
\   A(120) = Index_DIM_B_ActiveLeverPress_EventTime
\   A(121) = Index_DIM_C_InactiveLeverPress_EventTime
\   A(122) = Index_DIM_D_Infusions_EventTime
\   A(123) = Index_DIM_E_ActiveLeverPressesDuringTimeOut_EventTime
\   A(124) = Index_DIM_F_InactiveLeverPressesDuringTimeOut_EventTime

\   A(125) = Index_DIM_G_Totals_InterEventInterval_ActiveLeverPress
\   A(126) = Index_DIM_H_Totals_InterEventInterval_InactiveLeverPress
\   A(127) = Index_DIM_I_Totals_InterEventInterval_Infusions
\   A(128) = Index_DIM_J_Totals_InterEventInterval_ActiveLeverPressesDuringTimeOut
\   A(129) = Index_DIM_K_Totals_InterEventInterval_InactiveLeverPressesDuringTimeOut

\   A(130) = Index_DIM_L_CurrentBlock_InterEventInterval_ActiveLeverPress
\   A(131) = Index_DIM_M_CurrentBlock_InterEventInterval_InactiveLeverPress
\   A(132) = Index_DIM_N_CurrentBlock_InterEventInterval_Infusions
\   A(133) = Index_DIM_O_CurrentBlock_InterEventInterval_ActiveLeverPressesDuringTimeOut
\   A(134) = Index_DIM_P_CurrentBlock_InterEventInterval_InactiveLeverPressesDuringTimeOut

\    A(135) = Index_LIST_Z - this list holds the active lever presses that should be rewarded on PR schedule
\    A(136) = Index_LIST_Y - This list holds the times between infusions that result from breaking the floor IR beam

\--variables to hold constants so they're in data file [190-199]--\
\    A(190) = ^MaxInfusionDuration
\    A(191) = ^FillCatheterDurationCentiseconds
\    A(192) = ^VarsPerBlock


\--data vars [200-x]--\
\   A(200) = ActiveLeverPresses_Total - number of active lever presses
\   A(201) = InactiveLeverPresses_Total - number of inactive lever presses
\   A(202) = Infusions_Total - number of infusions (i.e., lever retraction with light flashes)
\   A(203) = ActiveLeverPressesDuringTimeOut_Total - number of active lever presses during timeout
\   A(204) = InactiveLeverPressesDuringTimeOut_Total - number of inactive lever presses during timeout
\   A(205) = InterEventInterval_Mean_ActiveLeverPresses_Total - mean of time between events
\   A(206) = InterEventInterval_Variance_ActiveLeverPresses_Total - Variance of time between events
\   A(207) = InterEventInterval_Mean_InactiveLeverPresses_Total - mean of time between events
\   A(208) = InterEventInterval_Variance_InactiveLeverPresses_Total - Variance of time between events
\   A(209) = InterEventInterval_Mean_Infusions_Total - mean of time between events
\   A(210) = InterEventInterval_Variance_Infusions_Total - Variance of time between events
\   A(211) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Total - mean of time between events
\   A(212) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Total - Variance of time between events
\   A(213) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Total - mean of time between events
\   A(214) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Total - Variance of time between events
\   A(215) = PercentageActivePresses_Total
\   A(216) = FloorIR_Infusions_Total - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(300) = ActiveLeverPresses_Block01 - number of active lever presses
\   A(301) = InactiveLeverPresses_Block01 - number of inactive lever presses
\   A(302) = Infusions_Block01 - number of infusions (i.e., lever retraction with light flashes)
\   A(303) = ActiveLeverPressesDuringTimeOut_Block01 - number of active lever presses during timeout
\   A(304) = InactiveLeverPressesDuringTimeOut_Block01 - number of inactive lever presses during timeout
\   A(305) = InterEventInterval_Mean_ActiveLeverPresses_Block01 - mean of time between events
\   A(306) = InterEventInterval_Variance_ActiveLeverPresses_Block01 - Variance of time between events
\   A(307) = InterEventInterval_Mean_InactiveLeverPresses_Block01 - mean of time between events
\   A(308) = InterEventInterval_Variance_InactiveLeverPresses_Block01 - Variance of time between events
\   A(309) = InterEventInterval_Mean_Infusions_Block01 - mean of time between events
\   A(310) = InterEventInterval_Variance_Infusions_Block01 - Variance of time between events
\   A(311) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block01 - mean of time between events
\   A(312) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block01 - Variance of time between events
\   A(313) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block01 - mean of time between events
\   A(314) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block01 - Variance of time between events
\   A(315) = PercentageActivePresses_Block01
\   A(316) = FloorIR_Infusions_Block01 - number of infusions from breaking the IR beam in front of the active lever during acquisition


\   A(400) = ActiveLeverPresses_Block02 - number of active lever presses
\   A(401) = InactiveLeverPresses_Block02 - number of inactive lever presses
\   A(402) = Infusions_Block02 - number of infusions (i.e., lever retraction with light flashes)
\   A(403) = ActiveLeverPressesDuringTimeOut_Block02 - number of active lever presses during timeout
\   A(404) = InactiveLeverPressesDuringTimeOut_Block02 - number of inactive lever presses during timeout
\   A(405) = InterEventInterval_Mean_ActiveLeverPresses_Block02 - mean of time between events
\   A(406) = InterEventInterval_Variance_ActiveLeverPresses_Block02 - Variance of time between events
\   A(407) = InterEventInterval_Mean_InactiveLeverPresses_Block02 - mean of time between events
\   A(408) = InterEventInterval_Variance_InactiveLeverPresses_Block02 - Variance of time between events
\   A(409) = InterEventInterval_Mean_Infusions_Block02 - mean of time between events
\   A(410) = InterEventInterval_Variance_Infusions_Block02 - Variance of time between events
\   A(411) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block02 - mean of time between events
\   A(412) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block02 - Variance of time between events
\   A(413) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block02 - mean of time between events
\   A(414) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block02 - Variance of time between events
\   A(415) = PercentageActivePresses_Block02
\   A(416) = FloorIR_Infusions_Block02 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(500) = ActiveLeverPresses_Block03 - number of active lever presses
\   A(501) = InactiveLeverPresses_Block03 - number of inactive lever presses
\   A(502) = Infusions_Block03 - number of infusions (i.e., lever retraction with light flashes)
\   A(503) = ActiveLeverPressesDuringTimeOut_Block03 - number of active lever presses during timeout
\   A(504) = InactiveLeverPressesDuringTimeOut_Block03 - number of inactive lever presses during timeout
\   A(505) = InterEventInterval_Mean_ActiveLeverPresses_Block03 - mean of time between events
\   A(506) = InterEventInterval_Variance_ActiveLeverPresses_Block03 - Variance of time between events
\   A(507) = InterEventInterval_Mean_InactiveLeverPresses_Block03 - mean of time between events
\   A(508) = InterEventInterval_Variance_InactiveLeverPresses_Block03 - Variance of time between events
\   A(509) = InterEventInterval_Mean_Infusions_Block03 - mean of time between events
\   A(510) = InterEventInterval_Variance_Infusions_Block03 - Variance of time between events
\   A(511) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block03 - mean of time between events
\   A(512) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block03 - Variance of time between events
\   A(513) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block03 - mean of time between events
\   A(514) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block03 - Variance of time between events
\   A(515) = PercentageActivePresses_Block03
\   A(516) = FloorIR_Infusions_Block03 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(600) = ActiveLeverPresses_Block04 - number of active lever presses
\   A(601) = InactiveLeverPresses_Block04 - number of inactive lever presses
\   A(602) = Infusions_Block04 - number of infusions (i.e., lever retraction with light flashes)
\   A(603) = ActiveLeverPressesDuringTimeOut_Block04 - number of active lever presses during timeout
\   A(604) = InactiveLeverPressesDuringTimeOut_Block04 - number of inactive lever presses during timeout
\   A(605) = InterEventInterval_Mean_ActiveLeverPresses_Block04 - mean of time between events
\   A(606) = InterEventInterval_Variance_ActiveLeverPresses_Block04 - Variance of time between events
\   A(607) = InterEventInterval_Mean_InactiveLeverPresses_Block04 - mean of time between events
\   A(608) = InterEventInterval_Variance_InactiveLeverPresses_Block04 - Variance of time between events
\   A(609) = InterEventInterval_Mean_Infusions_Block04 - mean of time between events
\   A(610) = InterEventInterval_Variance_Infusions_Block04 - Variance of time between events
\   A(611) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block04 - mean of time between events
\   A(612) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block04 - Variance of time between events
\   A(613) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block04 - mean of time between events
\   A(614) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block04 - Variance of time between events
\   A(615) = PercentageActivePresses_Block04
\   A(616) = FloorIR_Infusions_Block04 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(700) = ActiveLeverPresses_Block05 - number of active lever presses
\   A(701) = InactiveLeverPresses_Block05 - number of inactive lever presses
\   A(702) = Infusions_Block05 - number of infusions (i.e., lever retraction with light flashes)
\   A(703) = ActiveLeverPressesDuringTimeOut_Block05 - number of active lever presses during timeout
\   A(704) = InactiveLeverPressesDuringTimeOut_Block05 - number of inactive lever presses during timeout
\   A(705) = InterEventInterval_Mean_ActiveLeverPresses_Block05 - mean of time between events
\   A(706) = InterEventInterval_Variance_ActiveLeverPresses_Block05 - Variance of time between events
\   A(707) = InterEventInterval_Mean_InactiveLeverPresses_Block05 - mean of time between events
\   A(708) = InterEventInterval_Variance_InactiveLeverPresses_Block05 - Variance of time between events
\   A(709) = InterEventInterval_Mean_Infusions_Block05 - mean of time between events
\   A(710) = InterEventInterval_Variance_Infusions_Block05 - Variance of time between events
\   A(711) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block05 - mean of time between events
\   A(712) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block05 - Variance of time between events
\   A(713) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block05 - mean of time between events
\   A(714) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block05 - Variance of time between events
\   A(715) = PercentageActivePresses_Block05
\   A(716) = FloorIR_Infusions_Block05 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(800) = ActiveLeverPresses_Block06 - number of active lever presses
\   A(801) = InactiveLeverPresses_Block06 - number of inactive lever presses
\   A(802) = Infusions_Block06 - number of infusions (i.e., lever retraction with light flashes)
\   A(803) = ActiveLeverPressesDuringTimeOut_Block06 - number of active lever presses during timeout
\   A(804) = InactiveLeverPressesDuringTimeOut_Block06 - number of inactive lever presses during timeout
\   A(805) = InterEventInterval_Mean_ActiveLeverPresses_Block06 - mean of time between events
\   A(806) = InterEventInterval_Variance_ActiveLeverPresses_Block06 - Variance of time between events
\   A(807) = InterEventInterval_Mean_InactiveLeverPresses_Block06 - mean of time between events
\   A(808) = InterEventInterval_Variance_InactiveLeverPresses_Block06 - Variance of time between events
\   A(809) = InterEventInterval_Mean_Infusions_Block06 - mean of time between events
\   A(810) = InterEventInterval_Variance_Infusions_Block06 - Variance of time between events
\   A(811) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block06 - mean of time between events
\   A(812) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block06 - Variance of time between events
\   A(813) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block06 - mean of time between events
\   A(814) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block06 - Variance of time between events
\   A(815) = PercentageActivePresses_Block06
\   A(816) = FloorIR_Infusions_Block06 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(900) = ActiveLeverPresses_Block07 - number of active lever presses
\   A(901) = InactiveLeverPresses_Block07 - number of inactive lever presses
\   A(902) = Infusions_Block07 - number of infusions (i.e., lever retraction with light flashes)
\   A(903) = ActiveLeverPressesDuringTimeOut_Block07 - number of active lever presses during timeout
\   A(904) = InactiveLeverPressesDuringTimeOut_Block07 - number of inactive lever presses during timeout
\   A(905) = InterEventInterval_Mean_ActiveLeverPresses_Block07 - mean of time between events
\   A(906) = InterEventInterval_Variance_ActiveLeverPresses_Block07 - Variance of time between events
\   A(907) = InterEventInterval_Mean_InactiveLeverPresses_Block07 - mean of time between events
\   A(908) = InterEventInterval_Variance_InactiveLeverPresses_Block07 - Variance of time between events
\   A(909) = InterEventInterval_Mean_Infusions_Block07 - mean of time between events
\   A(910) = InterEventInterval_Variance_Infusions_Block07 - Variance of time between events
\   A(911) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block07 - mean of time between events
\   A(912) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block07 - Variance of time between events
\   A(913) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block07 - mean of time between events
\   A(914) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block07 - Variance of time between events
\   A(915) = PercentageActivePresses_Block07
\   A(916) = FloorIR_Infusions_Block07 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(1000) = ActiveLeverPresses_Block08 - number of active lever presses
\   A(1001) = InactiveLeverPresses_Block08 - number of inactive lever presses
\   A(1002) = Infusions_Block08 - number of infusions (i.e., lever retraction with light flashes)
\   A(1003) = ActiveLeverPressesDuringTimeOut_Block08 - number of active lever presses during timeout
\   A(1004) = InactiveLeverPressesDuringTimeOut_Block08 - number of inactive lever presses during timeout
\   A(1005) = InterEventInterval_Mean_ActiveLeverPresses_Block08 - mean of time between events
\   A(1006) = InterEventInterval_Variance_ActiveLeverPresses_Block08 - Variance of time between events
\   A(1007) = InterEventInterval_Mean_InactiveLeverPresses_Block08 - mean of time between events
\   A(1008) = InterEventInterval_Variance_InactiveLeverPresses_Block08 - Variance of time between events
\   A(1009) = InterEventInterval_Mean_Infusions_Block08 - mean of time between events
\   A(1010) = InterEventInterval_Variance_Infusions_Block08 - Variance of time between events
\   A(1011) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block08 - mean of time between events
\   A(1012) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block08 - Variance of time between events
\   A(1013) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block08 - mean of time between events
\   A(1014) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block08 - Variance of time between events
\   A(1015) = PercentageActivePresses_Block08
\   A(1016) = FloorIR_Infusions_Block08 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(1100) = ActiveLeverPresses_Block09 - number of active lever presses
\   A(1101) = InactiveLeverPresses_Block09 - number of inactive lever presses
\   A(1102) = Infusions_Block09 - number of infusions (i.e., lever retraction with light flashes)
\   A(1103) = ActiveLeverPressesDuringTimeOut_Block09 - number of active lever presses during timeout
\   A(1104) = InactiveLeverPressesDuringTimeOut_Block09 - number of inactive lever presses during timeout
\   A(1105) = InterEventInterval_Mean_ActiveLeverPresses_Block09 - mean of time between events
\   A(1106) = InterEventInterval_Variance_ActiveLeverPresses_Block09 - Variance of time between events
\   A(1107) = InterEventInterval_Mean_InactiveLeverPresses_Block09 - mean of time between events
\   A(1108) = InterEventInterval_Variance_InactiveLeverPresses_Block09 - Variance of time between events
\   A(1109) = InterEventInterval_Mean_Infusions_Block09 - mean of time between events
\   A(1110) = InterEventInterval_Variance_Infusions_Block09 - Variance of time between events
\   A(1111) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block09 - mean of time between events
\   A(1112) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block09 - Variance of time between events
\   A(1113) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block09 - mean of time between events
\   A(1114) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block09 - Variance of time between events
\   A(1115) = PercentageActivePresses_Block09
\   A(1116) = FloorIR_Infusions_Block09 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(1200) = ActiveLeverPresses_Block10 - number of active lever presses
\   A(1201) = InactiveLeverPresses_Block10 - number of inactive lever presses
\   A(1202) = Infusions_Block10 - number of infusions (i.e., lever retraction with light flashes)
\   A(1203) = ActiveLeverPressesDuringTimeOut_Block10 - number of active lever presses during timeout
\   A(1204) = InactiveLeverPressesDuringTimeOut_Block10 - number of inactive lever presses during timeout
\   A(1205) = InterEventInterval_Mean_ActiveLeverPresses_Block10 - mean of time between events
\   A(1206) = InterEventInterval_Variance_ActiveLeverPresses_Block10 - Variance of time between events
\   A(1207) = InterEventInterval_Mean_InactiveLeverPresses_Block10 - mean of time between events
\   A(1208) = InterEventInterval_Variance_InactiveLeverPresses_Block10 - Variance of time between events
\   A(1209) = InterEventInterval_Mean_Infusions_Block10 - mean of time between events
\   A(1210) = InterEventInterval_Variance_Infusions_Block10 - Variance of time between events
\   A(1211) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block10 - mean of time between events
\   A(1212) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block10 - Variance of time between events
\   A(1213) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block10 - mean of time between events
\   A(1214) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block10 - Variance of time between events
\   A(1215) = PercentageActivePresses_Block10
\   A(1216) = FloorIR_Infusions_Block10 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(1300) = ActiveLeverPresses_Block11 - number of active lever presses
\   A(1301) = InactiveLeverPresses_Block11 - number of inactive lever presses
\   A(1302) = Infusions_Block11 - number of infusions (i.e., lever retraction with light flashes)
\   A(1303) = ActiveLeverPressesDuringTimeOut_Block11 - number of active lever presses during timeout
\   A(1304) = InactiveLeverPressesDuringTimeOut_Block11 - number of inactive lever presses during timeout
\   A(1305) = InterEventInterval_Mean_ActiveLeverPresses_Block11 - mean of time between events
\   A(1306) = InterEventInterval_Variance_ActiveLeverPresses_Block11 - Variance of time between events
\   A(1307) = InterEventInterval_Mean_InactiveLeverPresses_Block11 - mean of time between events
\   A(1308) = InterEventInterval_Variance_InactiveLeverPresses_Block11 - Variance of time between events
\   A(1309) = InterEventInterval_Mean_Infusions_Block11 - mean of time between events
\   A(1310) = InterEventInterval_Variance_Infusions_Block11 - Variance of time between events
\   A(1311) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block11 - mean of time between events
\   A(1312) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block11 - Variance of time between events
\   A(1313) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block11 - mean of time between events
\   A(1314) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block11 - Variance of time between events
\   A(1315) = PercentageActivePresses_Block11
\   A(1316) = FloorIR_Infusions_Block11 - number of infusions from breaking the IR beam in front of the active lever during acquisition

\   A(1400) = ActiveLeverPresses_Block12 - number of active lever presses
\   A(1401) = InactiveLeverPresses_Block12 - number of inactive lever presses
\   A(1402) = Infusions_Block12 - number of infusions (i.e., lever retraction with light flashes)
\   A(1403) = ActiveLeverPressesDuringTimeOut_Block12 - number of active lever presses during timeout
\   A(1404) = InactiveLeverPressesDuringTimeOut_Block12 - number of inactive lever presses during timeout
\   A(1405) = InterEventInterval_Mean_ActiveLeverPresses_Block12 - mean of time between events
\   A(1406) = InterEventInterval_Variance_ActiveLeverPresses_Block12 - Variance of time between events
\   A(1407) = InterEventInterval_Mean_InactiveLeverPresses_Block12 - mean of time between events
\   A(1408) = InterEventInterval_Variance_InactiveLeverPresses_Block12 - Variance of time between events
\   A(1409) = InterEventInterval_Mean_Infusions_Block12 - mean of time between events
\   A(1410) = InterEventInterval_Variance_Infusions_Block12 - Variance of time between events
\   A(1411) = InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block12 - mean of time between events
\   A(1412) = InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block12 - Variance of time between events
\   A(1413) = InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block12 - mean of time between events
\   A(1414) = InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block12 - Variance of time between events
\   A(1415) = PercentageActivePresses_Block12
\   A(1416) = FloorIR_Infusions_Block12 - number of infusions from breaking the IR beam in front of the active lever during acquisition


\   A(2000) = Dubugging

\blocks can continue indefinitely provided the "A" array is appropriately sized

\************************************************************




\************************************************************
\--ARRAYS--\

\--EVENT TIMES AND INTEREVENTINTERVALS--\


\-- index A(120) --\
DIM B = 50000   \ActiveLeverPress_EventTime

\-- index A(121) --\
DIM C = 50000   \InactiveLeverPress_EventTime

\-- index A(122) --\
DIM D = 50000   \Infusion_EventTime

\-- index A(123) --\
DIM E = 50000   \ActiveLeverPressesDuringTimeOut

\-- index A(124) --\
DIM F = 50000   \InactiveLeverPressesDuringTimeOut



\-- index A(125) --\
DIM G = 50000   \Totals_InterEventInterval_ActiveLeverPress

\-- index A(126) --\
DIM H = 50000   \Totals_InterEventInterval_InactiveLeverPress

\-- index A(127) --\
DIM I = 50000   \Totals_InterEventInterval_Infusions

\-- index A(128) --\
DIM J = 50000   \Totals_InterEventInterval_ActiveLeverPressesDuringTimeOut

\-- index A(129) --\
DIM K = 50000   \Totals_InterEventInterval_InactiveLeverPressesDuringTimeOut



\-- index A(130) --\
DIM L = 50000   \CurrentBlock_InterEventInterval_ActiveLeverPress

\-- index A(131) --\
DIM M = 50000   \CurrentBlock_InterEventInterval_InactiveLeverPress

\-- index A(132) --\
DIM N = 50000     \CurrentBlock_InterEventInterval_Infusions

\-- index A(133) --\
DIM O = 50000     \CurrentBlock_InterEventInterval_ActiveLeverPressesDuringTimeOut

\-- index A(134) --\
DIM P = 50000     \CurrentBlock_InterEventInterval_InactiveLeverPressesDuringTimeOut
\************************************************************




\************************************************************
\--TIME BETWEEN FLOOR IR INFUSIONS IN CENTISECONDS--\

\This is the time in centiseconds between each infusion
\that results from breaking the floor IR beam in front of the active
\lever. This corresponds to the following minutes:
\1, 2, 4, 8, 12, 16, 20, 24, 28, 30, 30, 30, etc. The idea is
\to shape the mice by first rewarding them for approaching the
\lever but ultimately requiring them to press the lever. After
\the first two hours mice will continue to get an infusion
\every 30 minutes just for approaching the lever. Hopefully
\this will enable mice that are not very exploratory and do
\not learn quickly to eventually learn to press the lever
\for cocaine.

LIST Y =     12000, 24000, 48000, 72000, 96000, 120000,
            144000, 168000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000,
            180000, 180000, 180000, 180000, 180000, 180000
\************************************************************



\************************************************************
\--PROGRESSIVE RATIO RESPONSE REQUIREMENT--\

\From "Progressive ratio schedules in drug self-administration
\studies in rats: a method to evaluate reinforcing efficacy."
\Nicole R. Richardson and David C.S. Roberts
\Journal of Neuroscience Methods 66 ( 1996) 1 - 11
\formula is: 5 x 2.71828^(injectionNum*0.2)] - 5

LIST Z =     1, 2, 4, 6, 9, 12, 15, 20, 25, 32, 40, 50, 62, 77,
            95, 118, 145, 178, 219, 268, 328, 402, 492, 603, 737,
            901, 1102, 1347, 1646, 2012, 2459, 3004, 3670, 4484,
            5478, 6692, 8175, 9986, 12198, 14900, 18200, 22230,
            27153, 33166, 40510, 49480, 60437, 73818, 90163,
            110127, 134510, 164292
\************************************************************



\************************************************************
\--MACROS--\
\   These macros give meaningful names to z pulses.

DefineMacro EndSession = {Z1}
DefineMacro EndBlock = {Z2}
DefineMacro DeliverInfusion = {Z3}
DefineMacro RetractBothLevers = {Z4}    \\\\\\\\\\NOT CURRENTLY USED
DefineMacro ActivePress_TimeOutInProgress = {Z5}
DefineMacro ActivePress_TimeOutNotInProgress = {Z6}
DefineMacro InactivePress_TimeOutInProgress = {Z7}
DefineMacro InactivePress_TimeOutNotInProgress = {Z8}
DefineMacro ActivePress_RecordEventTime = {Z9}
DefineMacro InactivePress_RecordEventTime = {Z10}
DefineMacro Infusion_RecordEventTime = {Z11}
DefineMacro ActivePressDuringTimeOut_RecordEventTime = {Z12}
DefineMacro InactivePressDuringTimeOut_RecordEventTime = {Z13}
DefineMacro DeliverDrugPairedStimuliAndTimeOut = {Z14}
DefineMacro Calculate_Total_PercentageActivePresses = {Z15}
DefineMacro DeliverTimeOutWithoutDrugPairedStimuli = {Z16}
DefineMacro FloorIRBreak_TimeOutNotInProgress = {Z17}
\************************************************************


\************************************************************
\--MISC--\
Y2KCOMPLIANT \The effect of this directive is to cause all dates appearing in data files and on printouts to appear as a 4-digit number.

\************************************************************

\************************************************************
\--NAMED VARIABLES--\
\These statements give meaningful names to all of
\the setting variables.
\Importantly, these var names can't
\be used in the program below.
\However, these names can be used in macros and will appear
\in the variable changing dialogue and box loading expert
\so you're not changing some obscure var name like A(60).

VAR_ALIAS Setting_ActiveLever_1_Left_2_Right = A(60)
VAR_ALIAS Setting_ExtinctionSession_1_True_0_False = A(61)
VAR_ALIAS Setting_InfusionDuration [centiseconds] = A(62)
VAR_ALIAS Setting_AcquisitionSession_1_True_0_False = A(63)
VAR_ALIAS Setting_DelayUntilStart [centiseconds] = A(64)
VAR_ALIAS Setting_HouseLightOffDelay [centiseconds] = A(65)
VAR_ALIAS Setting_HouseLightOnDelay [centiseconds] = A(66)
VAR_ALIAS Setting_FR_Or_PR_Schedule_1_FR_2_PR = A(67)
VAR_ALIAS Setting_FRResponseRequirement = A(68)
VAR_ALIAS Setting_TestingDuringDarkPeriod_1_True_0_False = A(69)
VAR_ALIAS Setting_BlockDuration [centiseconds] = A(70)
VAR_ALIAS Setting_NumberOfBlocksInSession = A(71)
VAR_ALIAS Setting_MaxSessionDuration = A(72)
VAR_ALIAS Setting_StimLightDuration [centiseconds] = A(73)
VAR_ALIAS Setting_TimeOutDuration [centiseconds] = A(74)
VAR_ALIAS Setting_InfusionsBeforeBlock1DuringAcquisition = A(75)
VAR_ALIAS Setting_DrugPairedStimuliDuringExtinction_1_True_0_False = A(76)
VAR_ALIAS Setting_DebuggingMode_1_True_0_False = A(77)
\************************************************************




\***********************************\
\****                           ****\
\****           MAIN            ****\
\****   PROGRAM STARTS HERE     ****\
\****                           ****\
\***********************************\


S.S.1,  \--INITIALIZE ARRAYS, CONVERT CONSTANTS TO TIMES, CHECK SETTING VARIABLES FOR ERRORS--\
        \S1 in this SS will fire as soon as the program is loaded and
        \will not wait for user to press start. Thus, insert a delay
        \after the load command in the macro before setting session
        \parameter vars [e.g., A(60), Setting_InfusionDuration].
        \S2 will fire when user presses start.


    S1, \--SET SESSION PARAMETERS--\
        0.01":  ZEROARRAY A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P;   \ZEROARRAY sets all of the elements of an array to 0.

                \Set setting variables to default - all of these can be changed using the macro provided there is
                \a delay (e.g., ~250 ms) between loading the IVSA program and setting the "setting vars" in the macro
                SET A(60) = 1;                    \   A(60) = Setting_ActiveLever_1_Left_2_Right
                SET A(61) =    0;                    \    A(61) = Setting_ExtinctionSession_1_True_0_False
                SET A(62) =    150;                \   A(62) = Setting_InfusionDuration [centiseconds]
                SET A(63) =    0;                    \    A(63) = Setting_AcquisitionSession_1_True_0_False - first block timer won't start until after "Setting_InfusionsBeforeBlock1DuringAcquisition" infusions during an acquisition session
                SET A(64) =    0;                    \    A(64) = Setting_DelayUntilStart [centiseconds] - this is used if you want to, for example, start the program at 4 pm but have the session start several hours later
                SET A(65) =    0;                    \    A(65) = Setting_HouseLightOffDelay [centiseconds] - set to zero if not using; if > 0 house light will be turned on at beginning of program and then turn off after indicated duration, presumably when overhead lights go off at night
                SET A(66) =    0;                    \    A(66) = Setting_HouseLightOnDelay [centiseconds] - set to zero if not using; if > 0 house light will turn on after indicated delay, presumably when overhead lights turn on in the morning - if program is still running it will override this
                SET A(67) =    1;                    \    A(67) = Setting_FR_Or_PR_Schedule_1_FR_2_PR
                SET A(68) =    1;                    \    A(68) = Setting_FRResponseRequirement [only used if FR schedule is selected]
                SET A(69) =    0;                    \    A(69) = Setting_TestingDuringDarkPeriod_1_True_0_False - if true house light will be off except during timeout; it false house light will be on except during timeout
                SET A(70) =    90000;                \    A(70) = Setting_BlockDuration [centiseconds] - block length in centiseconds
                SET A(71) =    8;                    \    A(71) = Setting_NumberOfBlocksInSession [max 195]- session will end as soon as this number is exceded
                SET A(72) =    3600000;            \    A(72) = Setting_MaxSessionDuration - session will end when this time is reached, regardless of anything else
                SET A(73) =    500;                \    A(73) = Setting_StimLightDuration [centiseconds] - length of stim lights on after a lever press; must be shorter than timeout
                SET A(74) =    2000;                \    A(74) = Setting_TimeOutDuration [centiseconds] - length of timeout after an infusion
                SET A(75) =    5;                    \    A(75) = Setting_InfusionsBeforeBlock1DuringAcquisition
                SET A(76) =    1;                    \    A(76) = Setting_DrugPairedStimuliDuringExtinction_1_True_0_False - only checked if we are using an extinction schedule as indicated by A(61)
                SET A(77) = 1;                    \    A(77) = Setting_DebuggingMode_1_True_0_False  - verbose output on the screen if True if false or any number other than "1" output will be non-verbose


                \ seal arrays that have their own index
                SET    B(A(120)) = -987.987;
                SET    C(A(121)) = -987.987;
                SET    D(A(122)) = -987.987;
                SET    E(A(123)) = -987.987;
                SET    F(A(124)) = -987.987;
                SET    G(A(125)) = -987.987;
                SET    H(A(126)) = -987.987;
                SET    I(A(127)) = -987.987;
                SET    J(A(128)) = -987.987;
                SET    K(A(129)) = -987.987;
                SET    L(A(130)) = -987.987;
                SET    M(A(131)) = -987.987;
                SET    N(A(132)) = -987.987;
                SET    O(A(133)) = -987.987;
                SET    P(A(134)) = -987.987;

                \set the current block to 1
                SET    A(40) = 1    ---> S2


    S2,    \--NO LONGER USED SO GO DIRECTLY TO S3--\
        #start: ---> S3

    S3, \--CHECK FOR ERRORS IN ACTIVE LEVER SETTING VARIABLE--\
        0.01": IF (A(60) = 1) OR (A(60) = 2) [@True, @False]         \If active lever is set to either left or right
                    @True,:  ---> S4                                    \everything is fine
                    @False: ---> STOPABORTFLUSH                        \else stop program.

    S4, \--CHECK FOR ERRORS IN EXTINCTION LEVER SETTING VARIABLE--\
        0.01":  IF (A(61) = 1) OR (A(61) = 0) [@True, @False]         \If extinction is set to either true or false
                    @True,:  ---> S5                                    \everything is fine
                    @False: ---> STOPABORTFLUSH                        \else stop program.

    S5, \--CHECK FOR ERRORS IN INFUSION DURATION SETTING VARIABLE--\
        0.01":    IF A(62) <= ^MaxInfusionDuration [@True, @False]     \If infusion duration is less than the maximum allowable infusion duration
                    @True,:     ---> S6                                    \everything is fine.
                    @False: ---> STOPABORTFLUSH                        \Else stop program.

    S6, \--CHECK FOR ERRORS IN AQUISITION SESSION SETTING VARIABLE--\
        0.01":  IF (A(63) = 0) OR (A(63) = 1) [@True, @False]         \If acquisition session setting variable is set to true or false
                    @True,:  ---> S7                                    \everything is fine
                    @False: ---> STOPABORTFLUSH                        \else stop program.

    S7, \--CHECK FOR ERRORS IN FR/PR SETTING VARIABLE--\
        0.01":    IF (A(67) = 1) OR (A(67) = 2) [@True, @False]         \If FR/PR setting variable is set to FR OR PR
                    @True,:   ---> S8                                \everything is fine
                    @False:  ---> STOPABORTFLUSH                    \else stop program.

    S8, \--CHECK FOR ERRORS IN TESTING DURING DARK PERIOD SETTING VARIABLE--\
        0.01":    IF (A(69) = 0) OR (A(69) = 1) [@True, @False]         \If Setting_TestingDuringDarkPeriod is set to true or false
                    @True,:   ---> S9                                \everything is fine
                    @False:  ---> STOPABORTFLUSH                    \else stop program.


S.S.2,  \--User starts the session by pressing the right liver twice--\

    S1, \--Wait for the user to start the program--\
        #start:      ON ^RightLever;
                    ON ^LeftLever    ---> S2

    S2,    \--Wait for the user to press the right lever twice to indicate that the mouse is in the chamber--\
        #R^RightLeverIR: ---> S3

    S3,    \--Then flash the house light and stimulus lights on and then off to indicate the user has started the session--\
        #R^RightLeverIR: ON ^HouseLight ---> S4

    S4, \--Flash lights--\
        0.5":     OFF ^HouseLight;
                ON ^LeftStim ---> S5

    S5, \--Flash lights--\
        0.5":     OFF ^LeftStim;
                ON ^RightStim ---> S6

    S6, \--Flash lights--\
        0.5":     OFF ^RightStim ---> S7

    S7, \--Wait a few seconds for tester to close the chamber door. Then extend the levers because the session has started--\
        0.01":     ON ^LeftLever;
                ON ^RightLever    ---> S8

    S8, \--Turn on or don't turn on the house light depending on whether we are testing during the dark or light part of the cycle--\
        0.01":    IF A(69) = ^True [@True, @False]     \If Setting_TestingDuringDarkPeriod is true then
            @True,: OFF ^HouseLight ---> S9
            @False: ON ^HouseLight ---> S9

    S9, \--Set the flag indicating the session has started--\
        0.01":    SET A(82) = ^True ---> S10


S.S.3,  \--SESSION TIMER--\

    S1,
        #start:  ---> S2

    S2,\--WAIT FOR THE USER TO PRESS THE RIGHT LEVER TO START THE SESSION--\
        0.01":  IF A(82) = 1 [@True, @False]     \If the user has pressed the right lever to indicate that the mouse is in the chamber and were ready to start the session
                    @True,: ---> S3                \Then go and start the session timer
                    @False: ---> S2             \Else keep waiting

    S3, \--SESSION TIMER - UPDATES EVERY 10 MS FOR ENTIRE SESSION--\
        0.01":  IF A(0) < A(72) [@True, @False]                        \If session timer is less than max session time
                    @True,: SET A(0) = A(0) + .01"    ---> S3            \update session timer by 10 ms.
                    @False: %EndSession%    ---> S32                \Else end the session.


S.S.4,  \--HOUSE LIGHT ON TIMER--\

    S1,
        #start:  ---> S2

    S2,\--WAIT FOR THE USER TO PRESS THE RIGHT LEVER TO START THE SESSION--\
        0.01":  IF A(82) = 1 [@True, @False]     \If the user has pressed the right lever to indicate that the mouse is in the chamber and were ready to start the session
                    @True,: ---> S3                \Then go and start the House light on timer
                    @False: ---> S2             \Else keep waiting

    S3, \--HOUSE LIGHT ON TIMER - UPDATES EVERY 10 MS Until the program stops--\
        0.01":  SET A(13) = A(13) + .01"    ---> S3            \update session timer by 10 ms Repeatedly until the program stops



S.S.5,  \--BLOCK TIMER--\

    S1,
        #start:    ---> S2

    S2,\--WAIT FOR THE USER TO PRESS THE RIGHT LEVER TO START THE SESSION--\
        0.01":  IF A(82) = 1 [@True, @False]     \If the user has pressed the right lever to indicate that the mouse is in the chamber and were ready to start the session
                    @True,: ---> S3                \Then go and start the session timer
                    @False: ---> S2             \Else keep waiting

    S3,
        0.01":    IF A(63) = 1 [@True, @False]    \if this is an acquisition session then
                    @True,: ---> S4                 \go to S4 and wait to start the first block timer until mouse gets a few infusions
                    @False: ---> S5                \Else go to S5 and start block timer now

    S4,
        0.01": IF A(202) >= A(75) [@True, @False]    \if mouse reaches criterion of infusions to start block 1
                    @True,: ---> S5                                                    \then start block 1
                    @False: ---> S4                                                    \else keep waiting

    S5,
        0.01":    IF A(1) > A(70) [@True, @False]     \if block is over
                    @True,: %EndBlock% ---> S5                              \end the block
                    @False: SET A(1) = A(1) + .01" ---> S5                \else increment block timer



S.S.6,  \--UPDATE DISPLAY--\
        \Display is composed of 5 columns, 40 rows per column.
        \Cells are numbered as shown below.

        \    1    2    3    4    5
        \    6    7    8    9    10
        \    11    12    13    14    15
        \    16    17    18    19    20
        \    21    22    23    24    25
        \    26    27    28    29    30
        \    31    32    33    34    35
        \    36    37    38    39    40
        \    41    42    43    44    45
        \    46    47    48    49    50
        \    51    52    53    54    55
        \    56    57    58    59    60
        \    61    62    63    64    65
        \    66    67    68    69    70
        \    71    72    73    74    75
        \    76    77    78    79    80
        \    81    82    83    84    85
        \    86    87    88    89    90
        \    91    92    93    94    95
        \    96    97    98    99    100
        \    101    102    103    104    105
        \    106    107    108    109    110
        \    111    112    113    114    115
        \    116    117    118    119    120
        \    121    122    123    124    125
        \    126    127    128    129    130
        \    131    132    133    134    135
        \    136    137    138    139    140
        \    141    142    143    144    145
        \    146    147    148    149    150
        \    151    152    153    154    155
        \    156    157    158    159    160
        \    161    162    163    164    165
        \    166    167    168    169    170
        \    171    172    173    174    175
        \    176    177    178    179    180
        \    181    182    183    184    185
        \    186    187    188    189    190
        \    191    192    193    194    195
        \    196    197    198    199    200



    S1, \--DETERMINE IF VERBOSE OR NON-VERBOSE OUTPUT--\
        #start: IF A(77) = 1 [@True, @False]    \if debugging mode setting variable is set to true
            @True,:  ---> S3                        \then do verbose output
            @False: ---> S2                        \else do non-verbose output



    S2, \--NON-VERBOSE SCREEN OUTPUT--\
        \--update the display once per second--\
        \--COLUMN 1--\
        1": SHOW 1, ActiveLever, A(60);
            SHOW 6, ExtinctionSession, A(61);
            \--COLUMN 2--\
            SHOW 2, SessionTime, A(10);
            SHOW 7, FloorIRInfusionsTotal, A(216);
            \--COLUMN 3--\
            SHOW 3, ActivePresses, A(200);
            SHOW 8, ActiveLeverPressesDuringTimeOutTotal, A(203);
            \--COLUMN 4--\
            SHOW 4, InactivePresses, A(201);
            SHOW 9, InactiveLeverPressesDuringTimeOutTotal, A(204);
            \--COLUMN 5--\
            SHOW 5,  InfusionsTotal, A(202);
            SHOW 10, PercentageActivePressesTotal, A(215);
            \--PROGRAM TIMER--\
            SET A(6) = A(6) + 0.01;                                 \--keeps track of time to display - just for display, not for internal use--\
            ADD A(7);                                                \--keeps track of seconds *up*to*60* - just for display, not for internal use--\
            ADD A(8);                                                \--keeps track of *total* seconds in session - just for display, not for internal use--\
            IF A(7) >= 60 [@AddMinute, @DoNotAddMinute]              \If 60 seconds have elapsed...
                @AddMinute:         SET A(6) = A(6) + 0.40;         \adjust display time to reflect that...
                                    SET A(7) = 0    ---> S2          \and reset seconds timer to zero
                @DoNotAddMinute:     ---> S2                          \else don't do anything


    S3, \--VERBOSE SCREEN OUTPUT--\
        \--update the display once per second--\
        \--COLUMN 1--\
        1": SHOW 1, Active Lever, A(60);
            SHOW 6, Program Time, A(6);
            SHOW 11, lever retraction timer, A(2);
            SHOW 16, flash duration timer, A(3);
            SHOW 21, flash frequency timer, A(4);
            SHOW 26, stop flashing timer , A(5);
            SHOW 31, block timer, A(1);
            SHOW 36, session time, A(0);
            SHOW 41, misc time, A(8);
            SHOW 46, CurrentBlock, A(40);
            SHOW 51, StimSide, A(2);
            SHOW 56, FlagTimeoutInProgress, A(80);
            SHOW 61, Index_DIM_B_ActiveLeverPress_EventTime, A(120);
            SHOW 66, Index_DIM_C_InactiveLeverPress_EventTime, A(121);
            SHOW 71, Index_DIM_D_Infusions_EventTime, A(122);
            SHOW 76, Index_DIM_E_ActiveLeverPressesDuringTimeOut_EventTime, A(123);
            SHOW 81, Index_DIM_F_InactiveLeverPressesDuringTimeOut_EventTime, A(124);
            SHOW 86, Index_DIM_G_Totals_InterEventInterval_ActiveLeverPress, A(125);
            SHOW 91, Index_DIM_H_Totals_InterEventInterval_InactiveLeverPress, A(126);
            SHOW 96, Index_DIM_I_Totals_InterEventInterval_Infusions, A(127);
            SHOW 101, Index_DIM_J_Totals_InterEventInterval_ActiveLeverPressesDuringTimeOut, A(128);
            SHOW 106, Index_DIM_K_Totals_InterEventInterval_InactiveLeverPressesDuringTimeOut, A(129);
            SHOW 111, Index_DIM_L_CurrentBlock_InterEventInterval_ActiveLeverPress, A(130);
            SHOW 116, Index_DIM_M_CurrentBlock_InterEventInterval_InactiveLeverPress, A(131);
            SHOW 121, Index_DIM_N_CurrentBlock_InterEventInterval_Infusions, A(132);
            SHOW 126, Index_DIM_O_CurrentBlock_InterEventInterval_ActiveLeverPressesDuringTimeOut, A(133);
            SHOW 131, Index_DIM_P_CurrentBlock_InterEventInterval_InactiveLeverPressesDuringTimeOut, A(134);
            SHOW 136, ActiveLeverPresses_Total, A(200);
            SHOW 141, InactiveLeverPresses_Total, A(201);
            SHOW 146, FloorIR_Infusions_Total, A(216);
            SHOW 151, FloorIR_Infusions_Block01, A(316);
            SHOW 156, FloorIR_Infusions_Block02, A(416);
            SHOW 161, InterEventInterval_Mean_ActiveLeverPresses_Total, A(205);
            SHOW 166, InterEventInterval_Variance_ActiveLeverPresses_Total, A(206);
            SHOW 171, InterEventInterval_Mean_InactiveLeverPresses_Total, A(207);
            SHOW 176, InterEventInterval_Variance_InactiveLeverPresses_Total, A(208);
            SHOW 181, InterEventInterval_Mean_Infusions_Total, A(209);
            SHOW 186, InterEventInterval_Variance_Infusions_Total, A(210);
            SHOW 191, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Total, A(211);
            SHOW 196, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Total, A(212);


\================================================\

            \--COLUMN 2--\
            SHOW 2, Extinction_Session, A(61);
            SHOW 7, Session Time, A(10);
            SHOW 12, PercentageActivePresses_Total, A(215);
            SHOW 17, ActiveLeverPresses_Block01, A(300);
            SHOW 22, InactiveLeverPresses_Block01, A(301);
            SHOW 27, Infusions_Block01, A(302);
            SHOW 32, ActiveLeverPressesDuringTimeOut_Block01, A(303);
            SHOW 37, InactiveLeverPressesDuringTimeOut_Block01, A(304);
            SHOW 42, InterEventInterval_Mean_ActiveLeverPresses_Block01, A(305);
            SHOW 47, InterEventInterval_Variance_ActiveLeverPresses_Block01, A(306);
            SHOW 52, InterEventInterval_Mean_InactiveLeverPresses_Block01, A(307);
            SHOW 57, InterEventInterval_Variance_InactiveLeverPresses_Block01, A(308);
            SHOW 62, InterEventInterval_Mean_Infusions_Block01, A(309);
            SHOW 67, InterEventInterval_Variance_Infusions_Block01, A(310);
            SHOW 72, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block01, A(311);
            SHOW 77, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block01, A(312);
            SHOW 82, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block01, A(313);
            SHOW 87, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block01, A(314);
            SHOW 92, PercentageActivePresses_Block01, A(315);
            SHOW 97, ActiveLeverPresses_Block02, A(400);
            SHOW 102, InactiveLeverPresses_Block02, A(401);
            SHOW 107, Infusions_Block02, A(402);
            SHOW 112, ActiveLeverPressesDuringTimeOut_Block02, A(403);
            SHOW 117, InactiveLeverPressesDuringTimeOut_Block02, A(404);
            SHOW 122, InterEventInterval_Mean_ActiveLeverPresses_Block02, A(405);
            SHOW 127, InterEventInterval_Variance_ActiveLeverPresses_Block02, A(406);
            SHOW 132, InterEventInterval_Mean_InactiveLeverPresses_Block02, A(407);
            SHOW 137, InterEventInterval_Variance_InactiveLeverPresses_Block02, A(408);
            SHOW 142, InterEventInterval_Mean_Infusions_Block02, A(409);
            SHOW 147, InterEventInterval_Variance_Infusions_Block02, A(410);
            SHOW 152, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block02, A(411);
            SHOW 157, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block02, A(412);
            SHOW 162, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block02, A(413);
            SHOW 167, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block02, A(414);
            SHOW 172, PercentageActivePresses_Block02, A(415);
            SHOW 177, ActiveLeverPresses_Block03, A(500);
            SHOW 182, InactiveLeverPresses_Block03, A(501);
            SHOW 187, Infusions_Block03, A(502);
            SHOW 192, ActiveLeverPressesDuringTimeOut_Block03, A(503);
            SHOW 197, InactiveLeverPressesDuringTimeOut_Block03, A(504);


\================================================\

            \--COLUMN 3--\
            SHOW 3, Active Presses, A(200);
            SHOW 8, ActiveLeverPressesDuringTimeOut_Total, A(203);
            SHOW 13, InterEventInterval_Mean_InactiveLeverPresses_Block03, A(507);
            SHOW 18, InterEventInterval_Variance_InactiveLeverPresses_Block03, A(508);
            SHOW 23, InterEventInterval_Mean_Infusions_Block03, A(509);
            SHOW 28, InterEventInterval_Variance_Infusions_Block03, A(510);
            SHOW 33, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block03, A(511);
            SHOW 38, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block03, A(512);
            SHOW 43, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block03, A(513);
            SHOW 48, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block03, A(514);
            SHOW 53, PercentageActivePresses_Block03, A(515);
            SHOW 58, ActiveLeverPresses_Block04, A(600);
            SHOW 63, InactiveLeverPresses_Block04, A(601);
            SHOW 68, Infusions_Block04, A(602);
            SHOW 73, ActiveLeverPressesDuringTimeOut_Block04, A(603);
            SHOW 78, InactiveLeverPressesDuringTimeOut_Block04, A(604);
            SHOW 83, InterEventInterval_Mean_ActiveLeverPresses_Block04, A(605);
            SHOW 88, InterEventInterval_Variance_ActiveLeverPresses_Block04, A(606);
            SHOW 93, InterEventInterval_Mean_InactiveLeverPresses_Block04, A(607);
            SHOW 98, InterEventInterval_Variance_InactiveLeverPresses_Block04, A(608);
            SHOW 103, InterEventInterval_Mean_Infusions_Block04, A(609);
            SHOW 108, InterEventInterval_Variance_Infusions_Block04, A(610);
            SHOW 113, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block04, A(611);
            SHOW 118, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block04, A(612);
            SHOW 123, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block04, A(613);
            SHOW 128, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block04, A(614);
            SHOW 133, PercentageActivePresses_Block04, A(615);
            SHOW 138, ActiveLeverPresses_Block05, A(700);
            SHOW 143, InactiveLeverPresses_Block05, A(701);
            SHOW 148, Infusions_Block05, A(702);
            SHOW 153, ActiveLeverPressesDuringTimeOut_Block05, A(703);
            SHOW 158, InactiveLeverPressesDuringTimeOut_Block05, A(704);
            SHOW 163, InterEventInterval_Mean_ActiveLeverPresses_Block05, A(705);
            SHOW 168, InterEventInterval_Variance_ActiveLeverPresses_Block05, A(706);
            SHOW 173, InterEventInterval_Mean_InactiveLeverPresses_Block05, A(707);
            SHOW 178, InterEventInterval_Variance_InactiveLeverPresses_Block05, A(708);
            SHOW 183, InterEventInterval_Mean_Infusions_Block05, A(709);
            SHOW 188, InterEventInterval_Variance_Infusions_Block05, A(710);
            SHOW 193, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block05, A(711);
            SHOW 198, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block05, A(712);
\================================================\

            \--COLUMN 4--\
            SHOW 4, Inactive Presses, A(201);
            SHOW 9, InactiveLeverPressesDuringTimeOut_Total, A(204);
            SHOW 14, PercentageActivePresses_Block05, A(715);
            SHOW 19, ActiveLeverPresses_Block06, A(800);
            SHOW 24, InactiveLeverPresses_Block06, A(801);
            SHOW 29, Infusions_Block06, A(802);
            SHOW 34, ActiveLeverPressesDuringTimeOut_Block06, A(803);
            SHOW 39, InactiveLeverPressesDuringTimeOut_Block06, A(804);
            SHOW 44, InterEventInterval_Mean_ActiveLeverPresses_Block06, A(805);
            SHOW 49, InterEventInterval_Variance_ActiveLeverPresses_Block06, A(806);
            SHOW 54, InterEventInterval_Mean_InactiveLeverPresses_Block06, A(807);
            SHOW 59, InterEventInterval_Variance_InactiveLeverPresses_Block06, A(808);
            SHOW 64, InterEventInterval_Mean_Infusions_Block06, A(809);
            SHOW 69, InterEventInterval_Variance_Infusions_Block06, A(810);
            SHOW 74, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block06, A(811);
            SHOW 79, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block06, A(812);
            SHOW 84, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block06, A(813);
            SHOW 89, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block06, A(814);
            SHOW 94, PercentageActivePresses_Block06, A(815);
            SHOW 99, ActiveLeverPresses_Block07, A(900);
            SHOW 104, InactiveLeverPresses_Block07, A(901);
            SHOW 109, Infusions_Block07, A(902);
            SHOW 114, ActiveLeverPressesDuringTimeOut_Block07, A(903);
            SHOW 119, InactiveLeverPressesDuringTimeOut_Block07, A(904);
            SHOW 124, InterEventInterval_Mean_ActiveLeverPresses_Block07, A(905);
            SHOW 129, InterEventInterval_Variance_ActiveLeverPresses_Block07, A(906);
            SHOW 134, InterEventInterval_Mean_InactiveLeverPresses_Block07, A(907);
            SHOW 139, InterEventInterval_Variance_InactiveLeverPresses_Block07, A(908);
            SHOW 144, InterEventInterval_Mean_Infusions_Block07, A(909);
            SHOW 149, InterEventInterval_Variance_Infusions_Block07, A(910);
            SHOW 154, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block07, A(911);
            SHOW 159, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block07, A(912);
            SHOW 164, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block07, A(913);
            SHOW 169, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block07, A(914);
            SHOW 174, PercentageActivePresses_Block07, A(915);
            SHOW 179, ActiveLeverPresses_Block08, A(1000);
            SHOW 184, InactiveLeverPresses_Block08, A(1001);
            SHOW 189, Infusions_Block08, A(1002);
            SHOW 194, ActiveLeverPressesDuringTimeOut_Block08, A(1003);
            SHOW 199, InactiveLeverPressesDuringTimeOut_Block08, A(1004);

\================================================\

            \--COLUMN 5--\
            SHOW 5,  Infusions_Total, A(202);
            SHOW 10, PercentageActivePresses_Total, A(215);
            SHOW 15, InterEventInterval_Mean_InactiveLeverPresses_Block08, A(1007);
            SHOW 20, InterEventInterval_Variance_InactiveLeverPresses_Block08, A(1008);
            SHOW 25, InterEventInterval_Mean_Infusions_Block08, A(1009);
            SHOW 30, InterEventInterval_Variance_Infusions_Block08, A(1010);
            SHOW 35, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block08, A(1011);
            SHOW 40, InterEventInterval_Variance_ActiveLeverPressesDuringTimeOut_Block08, A(1012);
            SHOW 45, InterEventInterval_Mean_InactiveLeverPressesDuringTimeOut_Block08, A(1013);
            SHOW 50, InterEventInterval_Variance_InactiveLeverPressesDuringTimeOut_Block08, A(1014);
            SHOW 55, PercentageActivePresses_Block08, A(1015);
            SHOW 60, ActiveLeverPresses_Block09, A(1100);
            SHOW 65, InactiveLeverPresses_Block09, A(1101);
            SHOW 70, Infusions_Block09, A(1102);
            SHOW 75, ActiveLeverPressesDuringTimeOut_Block09, A(1103);
            SHOW 80, InactiveLeverPressesDuringTimeOut_Block09, A(1104);
            SHOW 85, InterEventInterval_Mean_ActiveLeverPresses_Block09, A(1105);
            SHOW 90, InterEventInterval_Variance_ActiveLeverPresses_Block09, A(1106);
            SHOW 95, InterEventInterval_Mean_InactiveLeverPresses_Block09, A(1107);
            SHOW 100, InterEventInterval_Variance_InactiveLeverPresses_Block09, A(1108);
            SHOW 105, InterEventInterval_Mean_Infusions_Block09, A(1109);
            SHOW 110, InterEventInterval_Variance_Infusions_Block09, A(1110);
            SHOW 115, InterEventInterval_Mean_ActiveLeverPressesDuringTimeOut_Block09, A(1111);
            SHOW 120, Setting_ActiveLever, A(60);
            SHOW 125, Setting_ExtinctionSession, A(61);
            SHOW 130, Setting_InfusionDuration, A(62);
            SHOW 135, Setting_AcquisitionSession, A(63);
            SHOW 140, Setting_DelayUntilStart, A(64);
            SHOW 145, Setting_HouseLightOffDelay, A(65);
            SHOW 150, Setting_HouseLightOnDelay, A(66);
            SHOW 155, Setting_FR_Or_PR_Schedule, A(67);
            SHOW 160, Setting_FRResponseRequirement, A(68);
            SHOW 165, Setting_TestingDuringDarkPeriod, A(69);
            SHOW 170, Setting_BlockDuration, A(70);
            SHOW 175, Setting_NumberOfBlocksInSession, A(71);
            SHOW 180, Setting_MaxSessionDuration, A(72);
            SHOW 185, Setting_StimLightDuration, A(73);
            SHOW 190, Setting_TimeOutDuration, A(74);
            SHOW 195, Setting_InfusionsBeforeBlock1DuringAcquisition, A(75);
            SHOW 200, Debugging, A(76);

            \--PROGRAM TIMER--\
            SET A(6) = A(6) + 0.01;                                 \--keeps track of time to display - just for display, not for internal use--\
            ADD A(7);                                                \--keeps track of seconds *up*to*60* - just for display, not for internal use--\
            ADD A(8);                                                \--keeps track of *total* seconds in session - just for display, not for internal use--\
            IF A(7) >= 60 [@AddMinute, @DoNotAddMinute]              \If 60 seconds have elapsed...
                @AddMinute:         SET A(6) = A(6) + 0.40;         \adjust display time to reflect that...
                                    SET A(7) = 0    ---> S3          \and reset seconds timer to zero
                @DoNotAddMinute:     ---> S3                          \else don't do anything

\================================================\



\***********************************\
\****                           ****\
\****   WATCHERS START HERE     ****\
\****                           ****\
\***********************************\

S.S.7,  \--WATCHER - LEFT LEVER PRESSES--\

    S1,\--WAIT FOR THE USER TO PRESS THE RIGHT LEVER TO START THE SESSION--\
        0.01":  IF A(82) = 1 [@True, @False]     \If the user has pressed the right lever to indicate that the mouse is in the chamber and were ready to start the session
                    @True,: ---> S2                \Then start waiting for lever presses
                    @False: ---> S1             \Else keep waiting for the user to press the light right lever to start the program

    S2,    \--DECIDE WHAT TO DO WHEN THE LEFT LEVER IS PRESSED--\
        #R^LeftLeverIR:    IF A(60) = 1 [@True, @False]                                                 \Is left lever active
                            @True,:     IF A(80) = 1 [@True, @False]                                    \Is timeout in progress
                                        @True,:    %ActivePress_TimeOutInProgress%            ---> S2        \Active press timeout in progress
                                        @False:    %ActivePress_TimeOutNotInProgress%        ---> S2        \Active press timeout not in progress
                            @False: IF A(80) = 1 [@True, @False]                                    \Is timeout in progress
                                        @True,:    %InactivePress_TimeOutInProgress%        ---> S2        \Inactive press timeout in progress
                                        @False:    %InactivePress_TimeOutNotInProgress%    ---> S2        \Inactive press timeout not in progress


S.S.8,  \--WATCHER - RIGHT LEVER PRESSES--\

    S1,    \--WAIT FOR THE USER TO PRESS THE RIGHT LEVER TO START THE SESSION--\
        0.01":  IF A(82) = 1 [@True, @False]     \If the user has pressed the right lever to indicate that the mouse is in the chamber and were ready to start the session
                    @True,: ---> S2                \Then start waiting for lever presses
                    @False: ---> S1             \Else keep waiting for the user to press the light right lever to start the program

    S2,    \--DECIDE WHAT TO DO WHEN THE RIGHT LEVER IS PRESSED--\
        #R^RightLeverIR: IF A(60) = 2 [@True, @False]                                             \Is right lever active
                            @True,:     IF A(80) = 1 [@True, @False]                                    \Is timeout in progress
                                        @True,:    %ActivePress_TimeOutInProgress%            ---> S2        \Active press timeout in progress
                                        @False:    %ActivePress_TimeOutNotInProgress%        ---> S2        \Active press timeout not in progress
                            @False: IF A(80) = 1 [@True, @False]
                                        @True,:    %InactivePress_TimeOutInProgress%        ---> S2        \Inactive press timeout in progress
                                        @False:    %InactivePress_TimeOutNotInProgress%    ---> S2        \Inactive press timeout not in progress


S.S.9,  \--WATCHER - FLOOR IR BREAKS--\

    S1,    \--WAIT FOR THE USER TO PRESS THE RIGHT LEVER TO START THE SESSION--\
        0.01":  IF A(82) = ^True [@True, @False]     \If the user has pressed the right lever to indicate that the mouse is in the chamber and were ready to start the session
                    @True,: ---> S2                    \Then start waiting for floor ir breaks
                    @False: ---> S1                 \Else keep waiting for the user to press the right lever to start the program

    S2,    \--DETERMINE IF WE ARE IN AN ACQUISITION SESSION--\
        0.01":    IF A(63) = ^True [@True, @False]    \If this is an acquisition session
                    @True,:    ---> S3                    \Then keep going to wait for floor IR breaks
                    @False:    ---> S32                \Else dead-end

    S3,    \--DECIDE WHAT TO DO WHEN THE FLOOR IR IS BROKEN--\
        #R^FloorIR:    IF A(80) = ^True [@True, @False]                            \If a timeout is in progress when the floor IR beam is broken
                        @True,:    ---> S3                                            \Then do nothing
                        @False:    %FloorIRBreak_TimeOutNotInProgress%    ---> S3        \Else deal with floor IR beam breaks when a timeout is not in progress



\************************************\
\****                            ****\
\**** SESSION TIMER FOR SCREEN   ****\
\**** NOT USED FOR INTERNAL TIME ****\
\****                            ****\
\************************************\


S.S.10,  \--SESSION TIMER and HOUSE LIGHT OFF TIMER FOR SCREEN - NOT USED FOR INTERNAL TIME--\

    S1, \--CHECK TO SEE IF SESSION TIMER HAS STARTED--\
        0.01":  IF A(0) > 0  [@True, @False]    \If session timer has started
                    @True,:    ---> S2                \then start session timer for display
                    @False: ---> S1                \else keep waiting

    S2, \--UPDATES EVERY 1 SECOND FOR ENTIRE SESSION--\
        1": SET A(10) = A(10) + 0.01;                                 \--keeps track of session time to display - just for display, not for internal use--\
            ADD A(11);                                                \--keeps track of session seconds *up*to*60* - just for display, not for internal use--\
            ADD A(12);                                                \--keeps track of *total* seconds in session - just for display, not for internal use--\
            IF A(11) >= 60 [@AddMinute, @DoNotAddMinute]              \If 60 seconds have elapsed...
                @AddMinute:         SET A(10) = A(10) + 0.40;         \adjust display time to reflect that...
                                    SET A(11) = 0    ---> S2          \and reset seconds timer to zero
                @DoNotAddMinute:     ---> S2                          \else don't do anything



\***********************************\
\****                           ****\
\****   Z PULSES START HERE     ****\
\****                           ****\
\***********************************\




S.S.15,    \--%FloorIRBreak_TimeOutNotInProgress%--\


    S1,\--Determine if we give a FloorIR infusion--\
        #Z17:    IF A(0) > A(14)    [@True, @False]        \If the current session time is greater then the session time at which the next floor IR infusion is allowed
                    @True,:    ---> S2                    \Then proceed to give an infusion
                    @False:    ---> S1                    \Else wait for the next floor IR break


    S2,\--We've decided to give the infusion, so start doing it--\
        0.01":  SET A(83) = ^True;                               \Set the flag indicating that a floor IR infusion is in progress. This lets the infusion procedure know which variables to increment.
                SET A(14) = A(0) + Y(A(136));                    \Sets the time at which the next floor IR infusion is allowed by adding the time in the Y array to the current session time
                %DeliverInfusion%;                                \Deliver the infusion
                %DeliverDrugPairedStimuliAndTimeOut%;            \Deliver drug paired stims and timeout also
                ADD A(136)    ---> S1                                \Increment the index holding the position in the Y array containing the times between infusions resulting from a FloorIR beam break.



S.S.16,    \--%DeliverTimeOutWithoutDrugPairedStimuli%--\

    S1, \--START TIMEOUT AND TURN ON TIMEOUT FLAG--\
        #Z16:    SET A(80) = 1 ---> S02        \start timeout and turn on Flag_TimeOutInProgress

    S2,    \--END TIMEOUT AND TURN OFF TIMEOUT FLAG--\
        A(74)#T:    SET A(80) = 0 ---> S01    \end timeout and turn off Flag_TimeOutInProgress



S.S.17,    \--%Calculate_Total_PercentageActivePresses%--\

    S1, \--Calculate_Total_PercentageActivePresses--\
        #Z15:     IF A(200) > 0 [@True, @False]                                    \If some active lever presses occurred
                    @True,:  SET A(215) = A(200) / (A(200) + A(201));            \calc percentage of active presses
                            SET A(215) = A(215) * 100     ---> S1                \turn into a percentage
                    @False: IF (A(200) = 0) AND (A(201) = 0) [@True, @False]    \if there were no responses at all
                                @True,:     SET A(215) = 9999999999 ---> S1            \put a flag in the data indicating that
                                @False: SET A(215) = 0 ---> S1                    \else set to zero indicating there were responses but none were on active lever



S.S.18,    \--%DeliverDrugPairedStimuliAndTimeOut%--\
        \House light is dealt with differently for light phase and dark phase testing.
        \If we're in light phase of light:dark cycle then house light is turned off at beginning of timeout and
        \stays off the whole time. If we're in dark phase of light:dark cycle then
        \house light stays off while stim lights are on and then comes on after stim lights
        \are turned off; house light is turned back on after timeout is over. The reason for this is
        \to maximize salience of the stim lights. That is, when stim lights are on
        \the house light is off so that stim lights are highly salient.

    S1, \--TURN ON TIMEOUT FLAG--\
        #Z14:    SET A(80) = 1 ---> S02                        \turn on Flag_TimeOutInProgress

    S2,    \--DETERMINE IF WE ARE TESTING DURING LIGHT PHASE OR DARK PHASE--\
        0.01":    IF A(69) = 1 [@True, @False]            \if we are testing during dark phase
                    @True,:    ---> S3                        \do dark phase timeout and stims
                    @False:    ---> S6                        \else do light phase timeout and stims

    S3,    \--DARK PHASE: SET TIMERS AND TURN ON STIMS--\
        0.01":    SET A(3) = A(73);                        \set stim timer    - timer takes the value of a setting variable
                SET A(3) = A(3) * 0.01";                \convert stim timer from int value to time value
                SET A(4) = A(74) - A(73);                \set house light timer - subtract stim light duration from timeout duration because house lights will come on after stim lights in dark phase                                        \turn off stims and on houselight when stim timer has elapsed
                SET A(4) = A(4) * 0.01";                \convert houselight timer from int value to time value
                IF A(60) = ^Right [@True, @False]        \If right lever is active
                    @True,:    ON ^RightStim    ---> S4        \then turn on right stim
                    @False:    ON ^LeftStim    ---> S4        \else turn on left stim

    S4,    \--DARK PHASE: OFF STIMS AND ON HOUSELIGHT--\
        A(3)#T: OFF ^LeftStim;
                OFF ^RightStim;
                ON ^HouseLight ---> S5

    S5,    \--DARK PHASE: END TIMEOUT--\
        A(4)#T:    OFF ^HouseLight;
                SET A(80) = 0;                \turn off Flag_TimeOutInProgress
                SET A(3) = 0;                \reset stim timer
                SET A(4) = 0 ---> S1        \reset house light timer

    S6,    \--LIGHT PHASE: SET TIMERS AND TURN ON STIMS--\
        0.01":    SET A(3) = A(73);                        \set stim timer    - timer takes the value of a setting variable
                SET A(3) = A(3) * 0.01";                \convert stim timer from int value to time value
                SET A(4) = A(74);                        \set house light timer - timer takes the value of a setting variable
                SET A(4) = A(4) * 0.01";                \convert houselight timer from int value to time value
                SET A(2000) = 99999;                    \debug
                OFF ^HouseLight;                        \turn off house light
                IF A(60) = ^Right [@True, @False]        \If right lever is active
                    @True,:    ON ^RightStim    ---> S7        \then turn on right stim
                    @False:    ON ^LeftStim    ---> S7        \else turn on left stim

    S7,    \--LIGHT PHASE: OFF STIMS--\
        A(3)#T: OFF ^LeftStim;
                OFF ^RightStim    ---> S8

    S8,    \--LIGHT PHASE: END TIMEOUT--\
        A(4)#T:    ON ^HouseLight;
                SET A(80) = 0;                \turn off Flag_TimeOutInProgress
                SET A(3) = 0;                \reset stim timer
                SET A(4) = 0 ---> S1        \reset house light timer


S.S.19, \--%InactivePressDuringTimeOut_RecordEventTime%--\

    S1,
        #Z13:    IF A(124) = 0 [@True, @False]                             \If a right lever press hasn't yet occurred then
                    @True,:  SET F(A(124)) = A(0);                         \record event time
                            ADD A(124);                                 \and increment index but don't record an interevent interval.
                            SET F(A(124)) = -987.987    ---> S1         \Then seal array.
                    @False: SET F(A(124)) = A(0);                        \Else record event time,
                            SET K(A(129)) = F(A(124)) - F(A(124) - 1);    \interevent interval for session and
                            SET P(A(134)) = F(A(124)) - F(A(124) - 1);    \interevent interval for current block.
                            ADD A(124);                                    \Then increment the indexes for event time and
                            ADD A(129);                                    \interevent interval for session and
                            ADD A(134);                                    \interevent interval for current block.
                            SET F(A(124)) = -987.987;                     \Then seal arrays.
                            SET K(A(129)) = -987.987;
                            SET P(A(134)) = -987.987    ---> S1


S.S.20, \--%ActivePressDuringTimeOut_RecordEventTime%--\

    S1,
        #Z12:    IF A(123) = 0 [@True, @False]                             \If a right lever press hasn't yet occurred then
                    @True,:  SET E(A(123)) = A(0);                         \record event time
                            ADD A(123);                                 \and increment index but don't record an interevent interval.
                            SET E(A(123)) = -987.987    ---> S1         \Then seal array.
                    @False: SET E(A(123)) = A(0);                        \Else record event time,
                            SET J(A(128)) = E(A(123)) - E(A(123) - 1);    \interevent interval for session and
                            SET O(A(133)) = E(A(123)) - E(A(123) - 1);    \interevent interval for current block.
                            ADD A(123);                                    \Then increment the indexes for event time and
                            ADD A(128);                                    \interevent interval for session and
                            ADD A(133);                                    \interevent interval for current block.
                            SET E(A(123)) = -987.987;                     \Then seal arrays.
                            SET J(A(128)) = -987.987;
                            SET O(A(133)) = -987.987    ---> S1



S.S.21, \--%Infusion_RecordEventTime%--\

    S1,
        #Z11:    IF A(122) = 0 [@True, @False]                             \If an infusion hasn't yet occurred then
                    @True,:  SET D(A(122)) = A(0);                         \record event time
                            ADD A(122);                                 \and increment index but don't record an interevent interval.
                            SET D(A(122)) = -987.987    ---> S1         \Then seal array.
                    @False: SET D(A(122)) = A(0);                        \Else record event time,
                            SET I(A(127)) = D(A(122)) - D(A(122) - 1);    \interevent interval for session and
                            SET N(A(132)) = D(A(122)) - D(A(122) - 1);    \interevent interval for current block.
                            ADD A(122);                                    \Then increment the indexes for event time and
                            ADD A(127);                                    \interevent interval for session and
                            ADD A(132);                                    \interevent interval for current block.
                            SET D(A(122)) = -987.987;                     \Then seal arrays.
                            SET I(A(127)) = -987.987;
                            SET N(A(132)) = -987.987    ---> S1



S.S.22, \--%InactivePress_RecordEventTime%--\

    S1,
        #Z10:    IF A(121) = 0 [@True, @False]                             \If a right lever press hasn't yet occurred then
                    @True,:  SET C(A(121)) = A(0);                         \record event time
                            ADD A(121);                                 \and increment index but don't record an interevent interval.
                            SET C(A(121)) = -987.987    ---> S1         \Then seal array.
                    @False: SET C(A(121)) = A(0);                        \Else record event time,
                            SET H(A(126)) = C(A(121)) - C(A(121) - 1);    \interevent interval for session and
                            SET M(A(131)) = C(A(121)) - C(A(121) - 1);    \interevent interval for current block.
                            ADD A(121);                                    \Then increment the indexes for event time and
                            ADD A(126);                                    \interevent interval for session and
                            ADD A(131);                                    \interevent interval for current block.
                            SET C(A(121)) = -987.987;                     \Then seal arrays.
                            SET H(A(126)) = -987.987;
                            SET M(A(131)) = -987.987    ---> S1



S.S.23, \--%ActivePress_RecordEventTime%--\

    S1,
        #Z9:    IF A(120) = 0 [@True, @False]                                 \If an active lever press hasn't yet occurred then
                    @True,:  SET B(A(120)) = A(0);                             \record event time
                            ADD A(120);                                        \and increment index but don't record an interevent interval.
                            SET B(A(120)) = -987.987 ---> S1                 \Then seal array.
                    @False: SET B(A(120)) = A(0);                            \Else record event time,
                            SET G(A(125)) = B(A(120)) - B(A(120) - 1);        \interevent interval for session
                            SET L(A(130)) = B(A(120)) - B(A(120) - 1);        \interevent interval for current block.
                            ADD A(120);                                        \Then increment the indexes for event time and
                            ADD A(125);                                        \interevent interval for session and
                            ADD A(130);                                        \interevent interval for current block.
                            SET B(A(120)) = -987.987;                         \Then seal arrays.
                            SET G(A(125)) = -987.987;
                            SET L(A(130)) = -987.987    ---> S1



S.S.24, \--%InactivePress_TimeOutNotInProgress%--\

    S1,
        #Z8:    ADD A(201);                                 \Increment InactiveLeverPresses_Total
                ADD A(201 + (^VarsPerBlock * A(40)));         \Increment InactiveLeverPresses_Block#
                %Calculate_Total_PercentageActivePresses%;    \calculate percentage of active presses
                %InactivePress_RecordEventTime%    ---> S1        \record event time for an inactive press


S.S.25, \--%InactivePress_TimeOutInProgress%--\

    S1,
        #Z7:    ADD A(201);                                                     \Increment InactiveLeverPresses_Total
                ADD A(201 + (^VarsPerBlock * A(40)));                             \Increment InactiveLeverPresses_Block#
                ADD A(204);                                                     \Increment InactiveLeverPressesDuringTimeOut_Total
                ADD A(204 + (^VarsPerBlock * A(40)));                            \Increment InactiveLeverPressesDuringTimeOut_Block#
                %Calculate_Total_PercentageActivePresses%;                        \calculate percentage of active presses
                %InactivePress_RecordEventTime%;                                \record event time for an inactive press
                %InactivePressDuringTimeOut_RecordEventTime%    ---> S1            \record event time for an inactive press during timeout


S.S.26, \--%ActivePress_TimeOutNotInProgress%--\

    S1,    \--INCREMENT ACTIVE PRESS VARS AND RECORD EVENT TIME--\
        #Z6:    %ActivePress_RecordEventTime%;                \record event time for an active press
                ADD A(200);                                 \Increment ActiveLeverPresses_Total
                ADD A(200 + (^VarsPerBlock * A(40)));         \Increment ActiveLeverPresses_Block#
                %Calculate_Total_PercentageActivePresses%;    \calculate percentage of active presses
                IF A(67) = 1 [@True, @False]                \If we're using an FR schedule
                    @True,:    ADD A(41) ---> S2                \increment the variable holding active presses since last infusion
                    @False:    ---> S2                            \else don't.

    S2,    \--DETERMINE THE SCHEDULE: EXTINCTION, FR OR PR--\
        0.01":    IF A(61) = 1 [@True, @False]                \If setup file indicates we are using an extinction schedule
                    @True,:    ---> S6                            \then determine which type of extinction we're doing
                    @False:    IF A(67) = 1 [@True, @False]    \else determine if we are using an FR1 or PR schedule.
                                @True,:    ---> S3                \Determine if we give infusion for FR schedule
                                @False:    ---> S4                \Determine if we give infusion for PR schedule

    S3,    \--FOR FR SCHEDULE DETERMINE IF WE INFUSE--\
        0.01":    IF A(41) >= A(68) [@True, @False]            \If we are at a lever press on which an infusion should be given for the FR schedule
                    @True,:    SET A(41) = 0 ---> S5            \reset var holding number of presses since last infusion for FR schedule and go give infusion
                    @False:    ---> S1                            \increment var holding number of presses since last infusion for FR schedule and don't give infusion

    S4,    \--FOR PR SCHEDULE DETERMINE IF WE INFUSE--\
        0.01":    IF A(200) >= Z(A(135)) [@True, @False]        \If we are at a lever press on which an infusion should be given for the PR schedule
                    @True,:    ADD A(135) ---> S5                \increment index holding number of active presses on which we should give infusion    and then go give an infusion
                    @False:    ---> S1                            \else don't do anything

    S5,    \--DO INFUSION--\
        0.01":    %DeliverInfusion%;                                \Deliver infusion
                %DeliverDrugPairedStimuliAndTimeOut% ---> S1

    S6,    \--DO EXTINCTION WITH OR WITHOUT DRUG PAIRED STIMULI--\
        0.01":    IF A(76) = 1 [@True, @False]                                \If we are delivering drug paired stimuli during extinction
                @True,:    ---> S5                                                \then give a normal infusion [this should be saline]
                @False:    %DeliverTimeOutWithoutDrugPairedStimuli% ---> S1    \else don't give drug paired stims [i.e., no infusion, no stims, no house light; lever presses are still partitioned into total, timeout, and non-timeout presses].



S.S.27, \--%ActivePress_TimeOutInProgress%--\

    S1,
        #Z5:    ADD A(200);                                                     \Increment ActiveLeverPresses_Total
                ADD A(200 + (^VarsPerBlock * A(40)));                             \Increment ActiveLeverPresses_Block#
                ADD A(203);                                                     \Increment ActiveLeverPressesDuringTimeOut_Total
                ADD A(203 + (^VarsPerBlock * A(40)));                             \Increment ActiveLeverPressesDuringTimeOut_Block#
                %Calculate_Total_PercentageActivePresses%;                        \calculate percentage of active presses
                %ActivePress_RecordEventTime%;                                    \record event time for an active press
                %ActivePressDuringTimeOut_RecordEventTime%    ---> S1                \record event time for an active press during timeout deliver



S.S.28, \--%EndSession%--\

    S1, \--SKIP TO S2--\
        #Z1: ---> S2

    S2, \--wait xx seconds to end the session--\
        0.01":     ---> S3

    S3,            \--this was for sealing arrays but then I started sealing them on the fly--\
        0.01":        ---> S4

    S4,    \--calculate mean and variance for Totals_InterEventInterval_ActiveLeverPress - but first ensure we have at least 3 values--\
        0.01":  IF A(125) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(205) = G, 0, (A(125) - 1);
                            SAMPLEVARIANCE A(206) = G, 0, (A(125) - 1)    ---> S5
                    @False: SET A(205) = 9999999999;
                            SET A(206) = 9999999999    ---> S5

    S5,    \--calculate mean and variance for Totals_InterEventInterval_InactiveLeverPress - but first ensure we have at least 3 values--\
        0.01":  IF A(126) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(207) = H, 0, (A(126) - 1);
                            SAMPLEVARIANCE A(208) = H, 0, (A(126) - 1)    ---> S6
                    @False: SET A(207) = 9999999999;
                            SET A(208) = 9999999999    ---> S6

    S6,    \--calculate mean and variance for Totals_InterEventInterval_Infusions - but first ensure we have at least 3 values--\
        0.01":  IF A(127) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(209) = I, 0, (A(127) - 1);
                            SAMPLEVARIANCE A(210) = I, 0, (A(127) - 1)    ---> S7
                    @False: SET A(209) = 9999999999;
                            SET A(210) = 9999999999    ---> S7

    S7,    \--calculate mean and variance for Totals_InterEventInterval_ActiveLeverPressesDuringTimeOut - but first ensure we have at least 3 values--\
        0.01":  IF A(128) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(211) = J, 0, (A(128) - 1);
                            SAMPLEVARIANCE A(212) = J, 0, (A(128) - 1)    ---> S8
                    @False: SET A(211) = 9999999999;
                            SET A(212) = 9999999999    ---> S8

    S8,    \--calculate mean and variance for Totals_InterEventInterval_ActiveLeverPressesDuringTimeOut - but first ensure we have at least 3 values--\
        0.01":  IF A(129) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(213) = K, 0, (A(129) - 1);
                            SAMPLEVARIANCE A(214) = K, 0, (A(129) - 1)    ---> S9
                    @False: SET A(213) = 9999999999;
                            SET A(214) = 9999999999    ---> S9

    S9,      \--Total_PercentageActivePresses--\
        0.01":     %Calculate_Total_PercentageActivePresses% ---> S10

    S10,    \--ASSIGN CONSTANT VALUES TO VARS SO THEY'RE IN THE DATA FILE--\
        0.01":  SET A(190) = ^VarsPerBlock;
                SET A(191) = ^FillCatheterDurationCentiseconds ---> S11

    S11,    \--TURN EVERYTHING OFF EXCEPT HOUSE LIGHT--\
        0.01":    OFF ^LeftLever;
                OFF ^RightLever;
                OFF ^PelletDispenser;
                OFF ^LeftStim;
                OFF ^RightStim;
                OFF ^SyringePump ---> S12

    S12,    \--ENSURE EVERYTHING IS OFF AFTER A DELAY--\
        10":    OFF ^LeftLever;
                OFF ^RightLever;
                OFF ^PelletDispenser;
                OFF ^LeftStim;
                OFF ^RightStim;
                OFF ^SyringePump    ---> S13

    S13,    \--IF WE'RE TESTING DURING THE DAY TURN HOUSE LIGHT ON AND EXIT NOW--\
        0.01":    IF A(69) = 0 [@True, @False]                            \if we're testing during the day
                    @True,:  LOCKON ^HouseLight    ---> STOPABORTFLUSH        \lockon house light and exit program now
                    @False:    ---> S14                                    \Else go and wait to turn on house light

    S14,    \--IF WE'RE HERE THEN WE'RE TESTING DURING THE NIGHT. SO, WAIT TO TURN HOUSE LIGHT ON AND EXIT--\
        0.01":    IF A(13) >= ^HouseLightBackOnTimerDuration [@True, @False]                         \when the dark phase of the light cycle ends (i.e., program time time is greater than time to turn house light on)
                    @True,:     LOCKON ^HouseLight    ---> STOPABORTFLUSH                                \lockon house light and exit program now.
                    @False:    ---> S14


S.S.29, \--%EndBlock%--\

    S1, \--%SKIP TO S2--\
        #Z2: ---> S2

    S2,    \--calculate mean and variance for Block#_InterEventInterval_ActiveLeverPress - but first ensure we have at least 3 values--\
        0.01":  IF A(130) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(205 + (^VarsPerBlock * A(40))) = L, 0, (A(130) - 1);
                            SAMPLEVARIANCE A(206 + (^VarsPerBlock * A(40))) = L, 0, (A(130) - 1)    ---> S3
                    @False: SET A(205 + (^VarsPerBlock * A(40))) = 9999999999;
                            SET A(206 + (^VarsPerBlock * A(40))) = 9999999999    ---> S3

    S3,    \--calculate mean and variance for Block#_InterEventInterval_InactiveLeverPress - but first ensure we have at least 3 values--\
        0.01":  IF A(131) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(207 + (^VarsPerBlock * A(40))) = M, 0, (A(131) - 1);
                            SAMPLEVARIANCE A(208 + (^VarsPerBlock * A(40))) = M, 0, (A(131) - 1)    ---> S4
                    @False: SET A(207 + (^VarsPerBlock * A(40))) = 9999999999;
                            SET A(208 + (^VarsPerBlock * A(40))) = 9999999999    ---> S4

    S4,    \--calculate mean and variance for Block#_InterEventInterval_Infusions - but first ensure we have at least 3 values--\
        0.01":  IF A(132) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(209 + (^VarsPerBlock * A(40))) = N, 0, (A(132) - 1);
                            SAMPLEVARIANCE A(210 + (^VarsPerBlock * A(40))) = N, 0, (A(132) - 1)    ---> S5
                    @False: SET A(209 + (^VarsPerBlock * A(40))) = 9999999999;
                            SET A(210 + (^VarsPerBlock * A(40))) = 9999999999    ---> S5

    S5,   \-- calculate mean and variance for Block#_InterEventInterval_ActiveLeverPressesDuringTimeOut - but first ensure we have at least 3 values--\
        0.01":  IF A(133) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(211 + (^VarsPerBlock * A(40))) = O, 0, (A(133) - 1);
                            SAMPLEVARIANCE A(212 + (^VarsPerBlock * A(40))) = O, 0, (A(133) - 1)    ---> S6
                    @False: SET A(211 + (^VarsPerBlock * A(40))) = 9999999999;
                            SET A(212 + (^VarsPerBlock * A(40))) = 9999999999    ---> S6

    S6,   \-- calculate mean and variance for Block#_InterEventInterval_InactiveLeverPressesDuringTimeOut - but first ensure we have at least 3 values--\
        0.01":  IF A(134) > 2 [@True, @False]
                    @True,:  ARITHMETICMEAN A(213 + (^VarsPerBlock * A(40))) = P, 0, (A(134) - 1);
                            SAMPLEVARIANCE A(214 + (^VarsPerBlock * A(40))) = P, 0, (A(134) - 1)    ---> S7
                    @False: SET A(213 + (^VarsPerBlock * A(40))) = 9999999999;
                            SET A(214 + (^VarsPerBlock * A(40))) = 9999999999    ---> S7

    S7,      \--CurrentBlock_PercentageActivePresses--\
        0.01":     SET A(43) = A(200 + (^VarsPerBlock * A(40)));                                                                                 \set temp var holding active presses in current block to make below calcs easier to understand
                SET A(44) = A(201 + (^VarsPerBlock * A(40)));                                                                                 \set temp var holding inactive presses in current block to make below calcs easier to understand
                IF A(43) > 0 [@True, @False]                                                                                                \If some a lever presses occurred
                                @True,:  SET A(215 + (^VarsPerBlock * A(40))) = A(43) / (A(43) + A(44));                                        \calc percentage of active presses
                                        SET A(215 + (^VarsPerBlock * A(40))) = A(215 + (^VarsPerBlock * A(40))) * 100 ---> S8                \turn into a percentage
                                @False: IF (A(43) = 0) AND (A(44) = 0) [@True, @False]                                                        \if there were no responses at all
                                            @True,:     SET A(215 + (^VarsPerBlock * A(40))) = 9999999999 ---> S8                                \put a flag in the data indicating that
                                            @False: SET A(215 + (^VarsPerBlock * A(40))) = 0 ---> S8                                        \else set to zero indicating there were responses but none were on active lever

    S8,    \--RESET THE ARRAYS HOLDING INTEREVENTINTERVALS FOR BLOCKS AND THEIR INDEXES--\
        0.01":  ZEROARRAY L, M, N, O, P;       \ZEROARRAY sets all of the elements of an array to 0.
                SET A(130) = 0;                \reset index for CurrentBlock_InterEventInterval_LeftLeverPress
                SET A(131) = 0;                \reset index for CurrentBlock_InterEventInterval_RightLeverPress
                SET A(132) = 0;                \reset index for CurrentBlock_InterEventInterval_Infusion
                SET A(133) = 0;                \reset index for urrentBlock_InterEventInterval_ActiveLeverPressesDuringTimeOut
                SET A(134) = 0;                \reset index for CurrentBlock_InterEventInterval_InactiveLeverPressesDuringTimeOut
                SET L(A(130)) = -987.987;    \Seal arrays.
                SET M(A(131)) = -987.987;
                SET N(A(132)) = -987.987;
                SET O(A(133)) = -987.987;
                SET P(A(134)) = -987.987    ---> S9

    S9, \--Update Block Number and Reset Block Timer--\
        0.01":    ADD A(40); \Block Number
                SET A(1) = 0"    ---> S10 \Block Timer

    S10, \--Determine if previous block was the last one--\
        0.01":  IF A(40) > A(71) [@GameOver, @KeepGoing]   \Determine if we have reached max trials in a session
                    @GameOver:    %EndSession% ---> S1       \we end sesion now.
                    @KeepGoing: ---> S1


\S.S.30, \--%DeliverInfusion%--\
\        \Use this S.S.30 with the pumps at JAX that will stay on
\        \for the exact duration that is dialed in to the pump.
\        \It is a safety feature so that if you
\        \lose connection with the computer or the
\        \program crashes the pump will still turn off.
\        \Irritatingly, this feature *prevents* you from turning the pump off programatically.
\        \You *must* instead set the time of the infusion on the pump, turn the pump on
\        \programatically and then let it finish pumping and turn itself off. To turn it back on
\        \you must then programatically send an "off" and then "on" signal to turn it back on.
\        \The problem with this is that you have to dial this in to each pump for each mouse every day if you're
\        \testing multiple mice in the chamber each day or, if not,
\        \each time you weigh the mouse. Also, the infusion duration is then not in the data
\        \file. You have to trust that whoever is testing the mice dialed it in correctly.
\        \Another problem with this is that you can't add extra time to the first infusion
\        \to fill the dead space in the cathter. So, the first infusion will have
\        \less cocaine than the rest. This will have a greater effect on lighter mice
\        \because the catheter dead space is a greater percentage of the infusion
\        \for those mice. You could give an extra infusion after the first but you still have
\        \the weight confound. Take home message is don't buy these expensive complicated
\        \pumps with variable infusion speeds and durations. Get the inexpensive single-speed
\        \pump from Med Assoc with the specific motor you will need; that option is cheaper and provides
\        \full programatic control with only a slight risk that uncontrolled infusion will kill
\        \the mouse [it never happened at Memphis with ~200 mice and old pumps and sketchey equipment].
\
\    S1,    \-- TURN ON SYRINGE PUMP --\
\        #Z3:    ON ^SyringePump;                                            \Turn on syringe pump; it will stay on for whatever time is dialed in to the hardware on the pump which should be 0.1 sec
\                IF A(83) = ^True [@True, @False]                            \If this infusion resulted from a FloorIR beam break
\                    @True,:    SET A(83) = ^False;                                \reset the flag Flag_FloorIRInfusionInProgress which indicated that this infusion was the result of a floor IR beam break
\                            ADD A(216);                                     \Then increment FloorIR_Infusions_Total
\                            ADD A(216 + (^VarsPerBlock * A(40))) ---> S2    \increment FloorIR_Infusions_Block#
\
\                    @False: ADD A(202);                                \Else Increment Infusions_Total
\                            ADD A(202 + (^VarsPerBlock * A(40)));    \Increment Infusions_Block#
\                            %Infusion_RecordEventTime% ---> S2        \Record infusion event time
\
\    S2,    \--SEND OFF SIGNAL TO SYRINGE PUMP --\
\        \Syringe pump will turn off automatically based on time dialed in to the hardware switch on the pump. This will vary
\        \based on mouse weight. A 25 g mouse gets 1.5 seconds infusion. Thus, a 100 gram mouse would get 6 sec. So, the pump will
\        \have finished for all mice well before 10 seconds, at which point we'll send the off signal to prepare for next infusion.
\
\        10":    OFF ^SyringePump ---> S1                            \send off signal to syringe pump; it should have already turned itself off
\
\
\
\
\






\-- USE FUNCTION BELOW WITH PUMP THAT YOU CAN TURN ON AND OFF PROGRAMATICALLY --\
S.S.30, \--%DeliverInfusion%--\
        \Use this S.S.30 with a pump that you can turn on and off programatically like the Razel pumps I used at memphis.
        \If it is like the pumps at JAX, use the S.S.30 above. The ones at JAX would stay on
        \for the exact duration that is dialed in to the pump. So, you have to cycle it on and off
        \in 100 msec increments [lowest time you could set on the pump] until you reach the infusion duration.
        \It is a safety feature so that if you
        \lose connection with the computer the pump will still turn off.


    S1, \-- SET INFUSION DURATION TIMER --\
        #Z3:    IF A(122) = 0 [@True, @False]                                                 \If this is the first infusion
                    @True,:  SET A(2) = A(62) + ^FillCatheterDurationCentiseconds;             \set infusion duration to what is in the macro for this mouse and account for dead space in cath because this is the first infusion
                            ON ^SyringePump ---> S2                                            \turn on syringe pump
                    @False:    SET A(2) = A(62);                                                \set infusion duration to what is in the macro for this mouse
                            ON ^SyringePump ---> S2                                            \turn on syringe pump

    S2,    \--CONVERT INFUSION DURATION FROM AN INTEGER TO A TIME--\
        0.01":    SET A(2) = A(2) * 0.01"    ---> S3            \convert integer in centiseconds to time in seconds.

    S3,    \--INCREMENT VARS--\
        0.01":    ADD A(202);                                 \Increment Infusions_Total
                ADD A(202 + (^VarsPerBlock * A(40)));        \Increment Infusions_Block#
                %Infusion_RecordEventTime% ---> S4            \record event time for an infusion

    S4,    \--STOP INFUSION--\
        A(2)#T:     OFF ^SyringePump;        \stop infusion
                    SET A(2) = 0 ---> S5    \reset infusion duration timer

    S5,    \--STOP INFUSION #2--\
        0.01":    OFF ^SyringePump ---> S6 \make sure infusion stops

    S6,    \--STOP INFUSION #3--\
        0.01":    OFF ^SyringePump ---> S1 \make sure infusion stops and go wait to give another infusion












